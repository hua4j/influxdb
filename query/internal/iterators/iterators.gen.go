// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: iterators.gen.go.tmpl

package iterators

import . "github.com/influxdata/influxdb/influxql"

type floatFilterIterator struct {
	input  FloatIterator
	cond   Expr
	fields map[string]IteratorMap
	m      map[string]interface{}
}

func newFloatFilterIterator(input FloatIterator, fields map[string]IteratorMap, cond Expr) *floatFilterIterator {
	return &floatFilterIterator{
		input:  input,
		cond:   cond,
		fields: fields,
		m:      make(map[string]interface{}, len(fields)),
	}
}

func (itr *floatFilterIterator) Next() (*FloatPoint, error) {
	for {
		p, err := itr.input.Next()
		if err != nil || p == nil {
			return nil, err
		}

		for name, field := range itr.fields {
			itr.m[name] = field.Value(p.Tags, p.Aux)
		}

		if !EvalBool(itr.cond, itr.m) {
			continue
		}
		return p, nil
	}
}

func (itr *floatFilterIterator) Stats() IteratorStats {
	return itr.input.Stats()
}

func (itr *floatFilterIterator) Close() error {
	return itr.input.Close()
}

type integerFilterIterator struct {
	input  IntegerIterator
	cond   Expr
	fields map[string]IteratorMap
	m      map[string]interface{}
}

func newIntegerFilterIterator(input IntegerIterator, fields map[string]IteratorMap, cond Expr) *integerFilterIterator {
	return &integerFilterIterator{
		input:  input,
		cond:   cond,
		fields: fields,
		m:      make(map[string]interface{}, len(fields)),
	}
}

func (itr *integerFilterIterator) Next() (*IntegerPoint, error) {
	for {
		p, err := itr.input.Next()
		if err != nil || p == nil {
			return nil, err
		}

		for name, field := range itr.fields {
			itr.m[name] = field.Value(p.Tags, p.Aux)
		}

		if !EvalBool(itr.cond, itr.m) {
			continue
		}
		return p, nil
	}
}

func (itr *integerFilterIterator) Stats() IteratorStats {
	return itr.input.Stats()
}

func (itr *integerFilterIterator) Close() error {
	return itr.input.Close()
}

type unsignedFilterIterator struct {
	input  UnsignedIterator
	cond   Expr
	fields map[string]IteratorMap
	m      map[string]interface{}
}

func newUnsignedFilterIterator(input UnsignedIterator, fields map[string]IteratorMap, cond Expr) *unsignedFilterIterator {
	return &unsignedFilterIterator{
		input:  input,
		cond:   cond,
		fields: fields,
		m:      make(map[string]interface{}, len(fields)),
	}
}

func (itr *unsignedFilterIterator) Next() (*UnsignedPoint, error) {
	for {
		p, err := itr.input.Next()
		if err != nil || p == nil {
			return nil, err
		}

		for name, field := range itr.fields {
			itr.m[name] = field.Value(p.Tags, p.Aux)
		}

		if !EvalBool(itr.cond, itr.m) {
			continue
		}
		return p, nil
	}
}

func (itr *unsignedFilterIterator) Stats() IteratorStats {
	return itr.input.Stats()
}

func (itr *unsignedFilterIterator) Close() error {
	return itr.input.Close()
}

type stringFilterIterator struct {
	input  StringIterator
	cond   Expr
	fields map[string]IteratorMap
	m      map[string]interface{}
}

func newStringFilterIterator(input StringIterator, fields map[string]IteratorMap, cond Expr) *stringFilterIterator {
	return &stringFilterIterator{
		input:  input,
		cond:   cond,
		fields: fields,
		m:      make(map[string]interface{}, len(fields)),
	}
}

func (itr *stringFilterIterator) Next() (*StringPoint, error) {
	for {
		p, err := itr.input.Next()
		if err != nil || p == nil {
			return nil, err
		}

		for name, field := range itr.fields {
			itr.m[name] = field.Value(p.Tags, p.Aux)
		}

		if !EvalBool(itr.cond, itr.m) {
			continue
		}
		return p, nil
	}
}

func (itr *stringFilterIterator) Stats() IteratorStats {
	return itr.input.Stats()
}

func (itr *stringFilterIterator) Close() error {
	return itr.input.Close()
}

type booleanFilterIterator struct {
	input  BooleanIterator
	cond   Expr
	fields map[string]IteratorMap
	m      map[string]interface{}
}

func newBooleanFilterIterator(input BooleanIterator, fields map[string]IteratorMap, cond Expr) *booleanFilterIterator {
	return &booleanFilterIterator{
		input:  input,
		cond:   cond,
		fields: fields,
		m:      make(map[string]interface{}, len(fields)),
	}
}

func (itr *booleanFilterIterator) Next() (*BooleanPoint, error) {
	for {
		p, err := itr.input.Next()
		if err != nil || p == nil {
			return nil, err
		}

		for name, field := range itr.fields {
			itr.m[name] = field.Value(p.Tags, p.Aux)
		}

		if !EvalBool(itr.cond, itr.m) {
			continue
		}
		return p, nil
	}
}

func (itr *booleanFilterIterator) Stats() IteratorStats {
	return itr.input.Stats()
}

func (itr *booleanFilterIterator) Close() error {
	return itr.input.Close()
}
